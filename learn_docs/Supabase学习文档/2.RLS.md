#### RLS（Row Level Security  - **行级权限控制**

​          是 PostgreSQL 自带的安全机制，Supabase 默认开启）： 

​	   核心概念：

​       	 开启 RLS 后，表默认“拒绝一切”，必须通过 Policy（策略决定谁能操作哪些行） 显式放行。

​    		Policy 由目标表、操作（select/insert/update/delete）、条件（using/with check）组成。

​		    auth.uid() 是当前会话的用户 ID；只有客户端带合法 JWT（anon/service key）才能识别。

​		    service role key 拥有绕过 RLS 的能力，仅应在安全的服务端/Edge Functions 使用，绝不能下发到前端。

​	   注意点：

​		    所有触发器函数必须是 SECURITY DEFINER（表示触发器角色是函数创建者（超级权限）），否则无法绕过 RLS

代码例子：

*-- 1. Create table*

create table profiles (  id uuid primary key,  user_id uuid references auth.users,  avatar_url text);

alter table profiles enable row level security; //开启RLS

create policy profiles_select_own on profiles
  for **select** using (auth.uid() = id);  //创建策略

create policy profiles_update_own on profiles
  for **update** using (auth.uid() = id)
  **with check** (auth.uid() = id);

create policy profiles_insert_own on profiles
  for **insert** **with** **check** (auth.uid() = id);

create policy profiles_delete_own on profiles
  for **delete**  **using** (auth.uid() = id);



#### 实战注意事项

1) 启用顺序与最小授权

- 先开启 RLS，再逐条添加最小化策略；不要使用“permit all”。

- 前后端逻辑都要遵守相同的数据边界，避免服务端绕过策略写入意外数据。



#### 常见坑

- 开启 RLS 后忘记 insert policy，导致 403。

- insert/update 缺少 with check，导致越权写入。

- 使用 service key 在前端，等于绕过 RLS，极度危险。

- 视图或函数暴露敏感字段，策略未覆盖。

- 测试只用 service key，未覆盖真实受限场景。

#### 建议实践清单

- 每个表：启用 RLS + 为 select/insert/update/delete 明确策略。

- insert/update 必有 with check，select/delete 必有 using。

- 编写针对策略的最小化集成测试（不同用户/不同 org/无会话）。

- 用 anon key + 已登录 session 测试真实前端路径；服务端仅在必要时用 service key。

- 变更策略后，跑 SQL/psql 模拟和前端调用双重验证。







#### `Service Role Key`（服务角色密钥）

​		是 **Supabase 提供的最高权限 API 密钥**，专门用于「服务端 / 后台代码」与 Supabase 交互，核心是绕开 Row Level Security (RLS) 行级安全策略，拥有对数据库的全量操作权限，下面用通俗的方式讲清楚：

### 一、核心定位：Supabase 的 “超级管理员密钥”

Supabase 为不同场景设计了不同的 API 密钥，`Service Role Key` 是权限最高的那个，对比常用密钥更易理解：

| 密钥类型                           | 权限范围                                                     | 适用场景                                         |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| `anon key`（匿名密钥）             | 前端 / 客户端使用，受 RLS 策略严格限制（只能操作允许的行 / 表） | 未登录用户的公开操作（比如查看商品列表）         |
| `service_role key`（服务角色密钥） | 绕开所有 RLS 策略，拥有数据库「读 / 写 / 删 / 改」全权限，还能操作 `auth` 系统表 | 服务端后台任务（比如批量同步数据、定时清理数据） |

### 二、`Service Role Key` 的核心作用

1. **绕开 RLS 执行高权限操作**

   比如你之前的 `handle_new_user` 触发器用了 `SECURITY DEFINER`（超级权限），而如果在**服务端代码**中需要批量修改 `profiles` 表（不管 RLS 策略），就可以用 `service_role key` 初始化 Supabase 客户端：

   ```javascript
   // Node.js 服务端示例（前端绝对不能用！）
   import { createClient } from '@supabase/supabase-js';
   const supabase = createClient(
     '你的 Supabase URL',
     '你的 Service Role Key' // 高权限密钥
   );
   // 能修改所有用户的资料（绕开RLS）
   const { data } = await supabase.from('profiles').update({ avatar_url: '新头像' });
   ```

   

2. **操作 Supabase 内置系统表**

   普通密钥无法访问 `auth.users`（Supabase 内置用户表），但 `service_role key` 可以直接查询 / 修改：

   ```javascript
   // 批量查询所有用户的认证信息（前端绝对做不到）
   const { data } = await supabase.from('auth.users').select('*');
   ```

3. **执行后台自动化任务**

   比如定时清理 `profiles` 表中超过 1 年未登录的用户数据、批量同步第三方系统的用户信息到 Supabase，这些操作需要突破 RLS 限制，必须用 `service_role key`。

### 三、绝对禁忌：禁止在前端 / 客户端使用！

`service_role key` 是「权限核弹」—— 如果泄露或在前端（浏览器 / APP）使用，攻击者可以：

- 删除你的整个数据库；
- 修改所有用户的密码 / 邮箱；
- 窃取所有用户的隐私数据；

✅ 正确用法：只在**服务端代码**（Node.js/Java/Python 后台）、定时任务、迁移脚本中使用；

❌ 错误用法：前端代码、客户端 APP、浏览器控制台中使用。

### 五、和你之前代码的关联

你之前的触发器函数用 `SECURITY DEFINER` 实现了 “绕开 RLS 同步数据”，这和 `service_role key` 是**异曲同工**：

- `SECURITY DEFINER`：在数据库层面绕开 RLS；

- ```
  service_role key
  ```

  ：在代码层面绕开 RLS；

  二者都是为了让 “高权限后台操作” 能正常执行，且都只能在服务端 / 数据库层面使用。

### 总结

`Service Role Key` 是 Supabase 给服务端的「超级通行证」，核心是绕开 RLS 执行高权限操作，**仅能在服务端使用**，绝对不能暴露给前端。它的存在是为了解决 “RLS 限制下无法执行的后台任务”，是 Supabase 权限体系中 “兜底的高权限入口”。