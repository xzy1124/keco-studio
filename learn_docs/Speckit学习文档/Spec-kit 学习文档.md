## Spec-kit 学习文档

### 一. Spec-kit 是什么

**Spec-kit 是一套 AI 驱动的规范化软件开发流程体系（Spec-Driven Development，SDD）。**
 它将传统软件工程中的：

- 需求规格（Specification）
- 技术方案（Design Plan）
- 任务拆分（Task Breakdown）
- 实现与测试（Implementation w/ TDD）

用一套稳定的指令流封装起来，让 AI 能在一个统一规则下生成**高一致性、高可维护性**的系统代码。

Spec-kit 的核心特性：

1. **过程严格、文档驱动**
    所有代码都只能根据生成的 `spec.md` + `plan.md` + `tasks.md` 来写。
2. **强制 TDD 先行**
    `/implement` 阶段会先生成测试，再生成实现。
3. **稳定可控**
    引入 `/constitution` 作为“项目宪法”，统一工程规范。
4. **适合多人协作 / 大型项目 AI 生成代码**
    避免 chat 乱飞、风格不一致、生成不可复现。

一句话总结：
 **Spec-kit ≠ 只是命令工具，它是一种新的软件开发方法论。**

------

### 二. Spec-kit 安装方式

参考链接： https://github.com/github/spec-kit

------

### 三. Spec-kit 核心命令说明

------

### 1. `/constitution`（项目宪法）

它是 Spec-kit 的“顶层规则体系”，约束所有步骤。

参考例子（现在keco-studio项目使用的constitution，可统一修改）：

```
/spec-kit.constitution 代码编写原则
1. 设计还原：基于F2C MCP的Figma设计稿实现像素级还原，包含尺寸/样式/交互态，并且使用响应式布局；
2. 技术栈：
   - Next.js：遵循App Router，避免水合错误，组件按需导入；
   - Supabase：适配RLS策略，Migration脚本管理表结构，数据双端校验；
   - 样式：.module.css模块化，提取CSS变量，样式复用无全局污染；
3. 代码规范：
   - 最小依赖，锁定package.json版本，无冗余库；
   - TypeScript严格模式，无any类型，核心逻辑注释；
   - 异步操作全量错误处理，避免崩溃；
4. 简洁性：逻辑清晰，组件单一职责，命名语义化。
```

宪法的作用：

- 避免 AI 乱用技术
- 确保所有代码风格一致
- 确保设计落地规范统一

### 2. `/specify`（规格定义）

**作用：把模糊的需求 → 变成精确、可验证的规格。**
 输出文件：`spec.md`

内容包含：

- 用户故事（User Story）
- 功能描述（What）
- 非功能需求（NFR）
- 验收标准（Acceptance Criteria）
- 边界条件（Edge Cases）
- Out of Scope（不做的点）

**最终的 `spec.md` 是整个系统的源头，所有后续产物都依赖它。**

注意！！！
 **生成后一定要人工仔细校验、补充，否则整个系统会“按错的方向完美执行”。**

------

### 3. `/clarify`（规格补充）

用途：

- 对 `spec.md` 进行修改、补充
- 添加遗漏的场景
- 明确一些歧义

它是对 `/specify` 的补救性增强，不会替代规格，而是**增量式补充**。

------

### 4. `/plan`（技术方案设计）

**作用：把 “要做什么” → 变成 “怎么做”。**
 输出包括多个文档（按模块拆分）：

- `plan.md`（总体方案）
- 数据模型（Database Schema）
- API 设计（OpenAPI / REST）
- 架构图 / Sequence Diagram
- 技术栈选型
- 约束条件 & 风险点

你写的很准确，我补充几点“专业化点”：

**必读注意事项**：

1. `/plan` 不负责写代码，它负责**约束代码的形状**
2. 这是 Spec-kit 中最需要“人工校验”的阶段，错误方案会导致错误实现
3. 如果最终实现发现问题，一般不是实现的问题，而是 plan 的问题 → 需回到 `/clarify` + `/plan` 修正

------

### 5. `/tasks`（任务拆分）

**作用：把整个方案拆成一系列可执行任务（包含依赖顺序）。**
 输出文件：`tasks.md`

内容一般包含：

- 任务编号
- 描述
- 依赖关系
- 文件路径
- 实现方式
- 优先级

示例（典型）：

```
1. 定义数据库 schema（依赖：spec）
2. 创建 Supabase migration（依赖：1）
3. 编写后端 API（依赖：2）
4. 编写 API 测试（依赖：3）
5. 开发前端页面（依赖：3）
```

**Spec-kit 在这一阶段将开发任务系统化，避免混乱开发。**

------

### 6. `/analyze`（一致性检查）

**这是 Spec-kit 中最“软件工程化”的一步。**

用途：

- 对比 `constitution`（项目宪法）
- 对比 `spec.md`
- 对比 `plan.md`
- 对比 `tasks.md`

寻找：

- 冲突
- 歧义
- 方案缺失
- 任务顺序错误
- 不可实现项

输出通常是一个问题列表：

- 哪些 spec 没被 plan 覆盖
- 哪些 plan 没有任务
- 哪些任务无法对应代码路径
- 哪些 edge case 未被考虑

它是“上线前的设计评审”级别的分析。

------

### 7. `/implement`（代码实现 + TDD）

**作用：基于 tasks.md 逐任务生成真实代码。**

特点：

1. 严格先写测试
2. 再写实现
3. 跑测试
4. 根据失败信息修正代码
5. 输出完整可运行项目代码（文件树 + 内容）

重要注意点（你提到的很关键）：

**可以新建一个chat对话窗口。**
 因为：

- 避免上下文污染
- 实现阶段只需要 tasks + plan + spec
- 对话过长 Chat 会遗忘重要上下文

------

### 8. 如何为已有项目添加新功能？

流程完全相同：

1. `/specify` 新功能（最好指出现有项目的上下文和约束）
2. `/clarify` 增量补充
3. `/plan` 扩展现有架构
4. `/tasks` 拆分任务
5. `/analyze` 检查新增内容是否与旧系统冲突
6. `/implement` 按任务写代码

**Spec-kit 的精髓：每次加功能都必须经过完整 SDLC，而不是直接写代码。**

------

### 四. Spec-kit 开发功能流程（完整 + 简化）

#### 完整流程（推荐）

```
/specify → /clarify → /plan → /tasks → /analyze → /implement
```

适合：

- 核心功能
- 高复杂度模块
- 多人协作环境
- 涉及数据库/API/前端联动

#### 简易流程（适用于小功能）

```
/specify → /plan → /tasks → /implement
```

适合：

- 较简单的静态组件
- 单页面的小功能
- 无数据库逻辑